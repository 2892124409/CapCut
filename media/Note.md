 # 音频拖动后残留旧声音问题

  ## 原因
  - Seek 时仅刷新解码器缓冲，但 `QAudioSink` 输出缓冲仍存有旧样本，导致拖动后先播放一段旧音频。
  - 旧音频样本写入设备后，音频时钟也会滞后目标，进度短暂回跳。

  ## 解决方案
  - 在 `AudioPlayer::seek` 中，执行：`requestFlush()` + `setDropUntil(target)`，并调用 `AudioDecoder::hardResetOutput()`
  重新创建 `QAudioSink`，彻底清空输出缓冲。
  - `AudioDecoder::processPacket` 中根据 `dropUntil` 丢弃目标之前的帧，不写入音频设备，也不推进时钟，直到达到目标后才
  恢复。
  - 钳位音频时钟到目标时间，防止回跳拉动进度条。

  ## 效果
  - 拖动后不再播放拖动前的残留音频，音频和进度从目标位置直接开始输出。  



  # 视频拖动后画面启动慢问题

  ## 原因
  - Seek 时视频解码器仍在解码/输出目标之前的帧，填满队列后才逐步到达目标，导致画面迟滞。
  - 旧帧未丢弃，首帧到达目标位置前视频会“等”音频或被早期帧占用队列，出现启动慢/卡住。

  ## 解决方案
  - 在 `VideoDecoder` 中引入 `dropUntil`：
    - 解码时若帧 PTS 早于目标（容差 20ms），直接丢弃，不入队、不显示。
    - 到达目标后清除 `dropUntil`，恢复正常解码。
  - 在 `VideoPlayerImpl::seek` / 重载挂起的 seek 时：
    - 对视频解码器调用 `setDropUntil(target)` 并刷新解码队列，确保旧帧被清空、只解码目标后的帧。

  ## 效果
  - Seek 后不再消耗/显示目标前的视频帧，首帧更快到达目标位置，音画同时从拖动点开始，画面启动延迟消除。


  